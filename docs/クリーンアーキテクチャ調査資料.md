
# クリーンアーキテクチャ調査資料（一般論）

作成日: 2025-12-28

## 1. 目的と前提

### 目的

- 「クリーンアーキテクチャ（Clean Architecture）」の一般的な考え方を整理し、設計・実装・レビューで共通言語として使える状態にする
- 特定の技術（Android/Compose、Spring、Node 等）に依存しない原則を中心にまとめる

### 前提（この資料で扱う範囲）

- “クリーンアーキテクチャ”は厳密なフレームワークではなく、依存関係の方向・責務分離・テスト容易性を高める設計指針
- 実プロジェクトでは「チーム規模・変更頻度・期限」に応じて簡略化・段階導入するのが一般的

## 2. クリーンアーキテクチャの要点（結論）

- **依存は内側へ**：ビジネスルール（中心）を、UI/DB/外部API（周辺）から独立させる
- **境界で変換**：層を跨ぐデータは、境界（Use CaseやInterface Adapter）で変換する
- **ポート&アダプタ**：中心は「インタフェース（ポート）」だけを知り、外側が実装（アダプタ）する
- **テスト容易性**：中心ほど純粋（副作用なし/少ない）に保ち、外側のI/Oは差し替え可能にする

## 3. 主要概念

### 3.1 4つの同心円（代表的な説明）

一般的には次の同心円（内側ほど安定・変更されにくい）で説明される。

1. **Entities（エンティティ）**
	 - 企業/ドメインの最重要ルール
	 - 複数のユースケースで共有され、長期的に安定

2. **Use Cases（ユースケース / アプリケーションビジネスルール）**
	 - アプリとしての振る舞い（例：注文確定、ユーザー登録）
	 - 入出力を定義し、エンティティを使って業務処理を組み立てる

3. **Interface Adapters（インタフェースアダプタ）**
	 - UIやDB、外部APIとユースケースの間の変換層
	 - Controller / Presenter / Gateway / Repository実装の置き場になることが多い

4. **Frameworks & Drivers（フレームワーク/ドライバ）**
	 - UIフレームワーク、DB、HTTPクライアント、OS、外部サービスSDKなど
	 - ここは最も変更が多く、差し替え対象になりやすい

### 3.2 依存関係ルール（Dependency Rule）

**重要ルール：ソースコードの依存は内側に向かう**。

- 外側（UI/DB/外部API）は内側（Use Case/Entity）に依存してよい
- 内側は外側の具体（DB実装、HTTP、フレームワーク）に依存してはならない
- 依存逆転（DIP）により、内側が必要とする抽象（interface）を内側に置き、外側が実装する

#### 図（依存の向き）

```text
外側（変更が多い）
	UI / Framework / DB / External
				│ depends on
				▼
	Interface Adapters
				│ depends on
				▼
	Use Cases
				│ depends on
				▼
	Entities（最も安定）
内側（変更が少ない）
```

### 3.3 関連概念との違い

- **レイヤードアーキテクチャ（3層: UI/Service/DB）**
	- 物理的な層分けが主。依存の向きが外→内に固定されないことがある（ServiceがDB実装にべったり等）

- **ヘキサゴナル（Ports & Adapters）**
	- クリーンアーキテクチャと親和性が高い。中心（ドメイン/ユースケース）にポートを置く考え方を強調

- **DDD（ドメイン駆動設計）**
	- ドメインモデルの作り方・境界づけ（Bounded Context）などの方法論。クリーンは依存関係・構造の指針
	- 両者は競合ではなく併用されることが多い

## 4. 典型的な責務分担（一般的パターン）

### 4.1 Entity

- 業務上のルールと整合性（不変条件）を表現する
- 例：金額は0以上、在庫は負にならない、ステータス遷移の制約など

### 4.2 Use Case

- 1つのユーザー価値（ユースケース）を実現する手続き
- 入力（Input）→処理→出力（Output）の形で表すことが多い
- DBやUIの詳細を知らず、抽象（Repositoryなど）越しに必要な情報を取得する

### 4.3 Interface Adapters

役割の例：

- Presenter/ViewModel：出力データをUIに都合の良い形へ変換
- Controller：UIイベント/HTTPリクエストをUse Case呼び出しへ変換
- Repository実装/Gateway：外部I/Oの具体実装（DB/HTTP/SDK）

### 4.4 Frameworks & Drivers

- DBドライバ、HTTPクライアント、Android/iOS、Webフレームワークなど
- 変更コストが高い（アップデート・非互換・環境差異）ため、中心から隔離して扱う

## 5. データモデルの使い分け（重要）

“1つのDTOを全層で使い回す”は境界を壊しやすい。一般には層ごとにモデルを分ける。

- **Domain Model（Entity/Value Object）**：業務ルール中心
- **Use Case Model（Input/Output）**：ユースケースの入出力（アプリ都合）
- **UI Model（View State）**：表示や入力の都合（Null許容、表示用文言、ローディング状態など）
- **Data Model（API/DB DTO）**：外部仕様の都合（フィールド名、型、互換性など）

境界で変換することで、外部仕様変更が中心に波及しにくくなる。

## 6. 依存性注入（DI）と境界設計

### 6.1 DIPの実践

- Use Case（内側）が必要とするポート（例：UserRepository）を内側に定義
- 外側（DB/HTTP）にその実装（例：SqlUserRepository、ApiUserRepository）を置く
- 組み立て（Composition Root）は最外周（アプリ起動点、DIコンテナ設定）に置く

### 6.2 Composition Root（組み立ての場所）

- アプリのエントリポイント（main/Activity/Application/Server起動）で依存を結線
- ここだけは「外側→内側」を横断してよい（ただし一箇所に閉じ込める）

## 7. よくある実装構成（フォルダ/モジュール）

プロジェクトの規模により次のいずれかが採用されやすい。

### 7.1 単一モジュール内でパッケージ分割（小〜中）

- domain/（Entity, ValueObject, DomainService）
- usecase/（Interactor, Input/Output, Port interface）
- adapter/（Presenter/ViewModel/Controller, Mapper）
- infra/（DB/HTTP/SDK実装）

### 7.2 マルチモジュール（中〜大）

- :domain（純Kotlin/純Javaなど、最内周）
- :usecase（アプリケーション層）
- :data（repository実装、remote/local datasourceなど）
- :app（UI/DI/Framework）

モジュール境界で依存方向を強制でき、誤依存の混入を防ぎやすい。

## 8. 典型ユースケースの流れ（例）

例："ユーザー一覧を取得して表示"（外部APIとローカルキャッシュがある想定）

1. UI（ボタン押下/画面表示）
2. Controller/ViewModel が Use Case を呼び出す
3. Use Case が Repository（ポート）に問い合わせる
4. Repository実装（アダプタ）が Remote/Local から取得し、Domainに変換
5. Use Case が Output を返す
6. Presenter/ViewModel が UI State に変換
7. UI が描画

## 9. メリット/デメリット（採用判断材料）

### メリット

- 仕様変更（UI刷新、DB変更、外部API変更）に強くなる
- 中心ロジックのテストがしやすい（I/Oをモック化）
- 役割分担が明確になり、レビュー観点が揃う

### デメリット/注意点

- 小規模では分割コストが上回ることがある（クラス/変換が増える）
- “層分割のための分割”になりやすい（価値のある境界かを常に確認）
- モデル変換が増えるため、Mapperの設計が雑だと逆に複雑化する

## 10. よくあるアンチパターン

- **Use Caseがフレームワーク型に依存**（例：Use CaseがAndroid Context/CoroutineScope/Room Entityを直接参照）
- **Repository interfaceが外部DTOを返す**（外部仕様が中心へ漏れる）
- **“万能DTO”の横断利用**（UI都合のnull/表示文字列がドメインへ侵入）
- **Interactorが何でも屋**（画面ロジック・変換・I/O制御がUse Caseに過密）

## 11. Android/Composeに当てはめる場合の一般的な整理（参考）

この節は「一般論としての当てはめ例」。プロジェクト方針で簡略化してよい。

- UI（Compose）
	- 画面状態（UI State）を描画し、イベントを上位へ伝える

- ViewModel
	- 画面の状態管理とUse Case呼び出し
	- 依存注入の受け口になりやすい

- Use Case
	- ビジネス処理（例：デバイス一覧取得、接続、権限確認の手続き）
	- “Android依存”は極力避け、必要ならポート化（PermissionChecker等）

- Data/Infra
	- USB/カメラSDK、DB、ネットワーク等のI/O
	- 端末依存・権限・ライフサイクル差異を吸収するアダプタ層

## 12. 導入チェックリスト（レビュー観点）

- 依存関係が内向きになっている（内側が外側の型を参照していない）
- ユースケースは「何をするか」が名前と入出力で明確
- 外部仕様（API/DB）変更が domain/usecase へ波及しにくい形になっている
- UI State と Domain Model が混ざっていない（境界で変換している）
- テスト方針：Use Case/Entity はユニットテスト可能、I/Oは差し替え可能
- Composition Root（DI設定）が散らばっていない

## 13. 参考文献（キーワード）

- Robert C. Martin（Uncle Bob）: Clean Architecture（概念の一次情報）
- SOLID原則（特にDIP）
- Ports & Adapters（Hexagonal Architecture）
- DDD（Entity/Value Object/Bounded Context）

---

### 付録A: 用語の簡易対応表

- Entity（DDDのEntityとは文脈が被るが、クリーンの“Entities”は広く“企業ビジネスルール”を指すことがある）
- Use Case = Interactor（実装クラス名としてInteractorと呼ぶことが多い）
- Port = 内側に置くinterface
- Adapter = 外側に置く実装

